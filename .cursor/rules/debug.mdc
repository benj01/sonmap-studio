---
description: 
globs: 
alwaysApply: true
---
# LogManager (Singleton) - Use it for the current issue. Deactivate logs that are not related to the current issue so we can focus

- Located in core/logging/log-manager.ts
- Implements a singleton pattern for centralized logging
- Supports multiple log levels: DEBUG, INFO, WARN, ERROR
- Includes features like rate limiting and source-specific filtering


Log Level Management
- Global log level setting (defaults to INFO)
- Component-specific log levels
- Hierarchical log level checking (source-specific overrides global)

Rate Limiting
- Implements rate limiting to prevent log spam
- Different rate limits for development (100ms) and production (1000ms)
- Tracks last log time per unique log entry

Memory Management
- Maximum log limit of 10,000 entries
- Automatic trimming of old logs when limit is reached

Data Sanitization
- Safe stringification of log data
- Handles circular references
- Truncates large arrays and objects
- Special handling for Error objects
- Omits internal properties and functions

Component-Specific Logging
The system pre-configures log levels for different components:

Core Components (INFO level)
- Auth
- FileManager
- ImportManager

UI Components (WARN level)
- MapView
- LayerList
- LayerItem
- MapContext
- Toolbar

Use the async/await dbLogger system for all logging
- Import from `@/utils/logging/dbLogger` for DB, API, and service utilities
- Use `DefaultLogger` or `useLogger` (React context) for UI/client code
- All logger methods (`info`, `warn`, `error`, `debug`) are async and must be awaited
- Always provide a structured context object (e.g., `{ userId, requestId, importLogId }`)
- Log at operation start, success, and error (with try/catch)
- Never use `console.log`, `console.error`, or custom logger instances (LogManager, createLogger) in production code

Log Level Management
- Configurable via `.env` or logging.config.json
- Supports global and source/component-specific log levels
- Hierarchical log level checking (source-specific overrides global)

Adapters & Extensibility
- Console and Supabase adapters available (see `core/logging/log-manager.ts`)
- Add new adapters by implementing `ILogAdapter` interface
- Enable/disable adapters via config

Rate Limiting & Memory Management
- Rate limiting prevents log spam (100ms dev, 1000ms prod)
- Max 10,000 log entries, auto-trim oldest

Data Sanitization
- Handles circular references, truncates large objects/arrays
- Special handling for Error objects
- Omits internal properties/functions

Usage Examples
```typescript
// ✅ DO: Use async dbLogger with context and lifecycle logging
async function getUserData(userId: string, requestId: string) {
  try {
    await dbLogger.info('getUserData.start', { userId, requestId });
    const result = await db.users.findUnique({ where: { id: userId } });
    await dbLogger.info('getUserData.success', { userId, requestId, resultCount: 1 });
    return result;
  } catch (error) {
    await dbLogger.error('getUserData.error', { userId, requestId, error });
    throw error;
  }
}

// ❌ DON'T: Use old logger patterns or console.log
function getUserData(userId) {
  try {
    console.log('Getting user data');  // No structured context
    return db.users.findUnique({ where: { id: userId } });
    // No success logging
  } catch (error) {
    logger.error('Error getting user data');  // Old pattern, no await, no context
    throw error;
  }
}
```

React/Client Usage
- Use `useLogger()` from `LoggerContext` for UI components
- Context is automatically provided via React context/provider

See also: [core/logging/README.md](mdc:core/logging/README.md), [cursor_rules.mdc](mdc:cursor_rules.mdc)

Update this rule whenever new adapters, patterns, or best practices are established.
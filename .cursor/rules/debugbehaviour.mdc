---
description: 
globs: 
alwaysApply: true
---
# Guidelines for bug fixing and similar work processes
When the user asks you for help with fixing a bug or an issue, follow these guidelines:
- make the neccessary "mental" analyzis first: Understand the question, understand the problem, etc.
- then think where the core issue could be located at
- think and find out where the responsible files could be located at 
- then look in the file to check if you can find the issue, making sure to look at the complete file, not just finishing when you come across the first or even second issue. Make sure you go through the whole file, as somethimes that will change the complete understanding in unexpected ways
- once you are sure you found the core issue, report back
- don't pay too much attention to keeping your analysis short, you can use as many tokens as you need for a good analysis. We are not limited in this regard. Of cause, it should not totally explode.
- If you don't get to the core issue right away, think where else to look for.
- You have full access to tools like grep commands. Make use of them whenever needed
- If you found another possibility where the core issue could be located at, look there. Repeat this process max. 3 time. If you found nothing promising, leave it be and give the user the information about the fact that you couldn't get to the root of the issue
- if you found the very likely cause or root issue, you can directly implement a fix for the issue. Make sure you are still are considering "the big picture", meaning you take into account what you know about the codebase. Never fix something locally in a way that is not applicable in an productive version of the webapp. There might be rare cases where a piece of code is inserted just for debugging, that is ok but the user should be informed about it

# General coding rules:
- If you have questions that concern how to handle specific libraries, use Context7 MCP
- If you feel that we came across a bigger issue that needs careful refactoring of the codebase, suggest to the user to use Taskmaster-AI MCP
- in such a case, provide the user with a promt that will summarize the ongoing issue. Tell the user with a message, that you'd suggest to start a new chat, and provide the user with a concrete promt in the right format so the user can just copy/paste it into a new chat without writing anything else. That would be the most user friendly way, and thats what we are achieving, giving our best performance.
- Reflect on yourself from time to time. That means, if you think the quality of your answers or "thinking progress" is decreasing - either based on your own "intuition" or from user feedback - suggest to the user to start a new chat, as this often increases the quality of the answers
- In such a case, also provide the user with a promt to start a new chat with. It should be formated in the right way, so the user can just copy the whole promt and paste it into a new chat as the starting promt. That means it describes the ongoing issue, the things we tried to solve the issue, mentions the relevent files, maybe point into a direction to where the solution might be (if we know of any)
- You can see the cursor rules that are added to every chat and you can also decide, if you want to see all rules (auto-attach/agent-Requested). If you ever feel a rule is outdated, please inform the user and make the suggestion to overwrite the content of that rule. Yuu can shortly describe why you would update the rule and if the users agrees to this, overwrite the content with a new rule that makes sense
- sometimes, in a longer chat, there is the tendency to drift off a core issue. If you notice that (which also means you have to "think back" from time to time to context from earlier on), point the user to this fact, and suggest where to concentrate to again
- I such a case, also provide the user with a promt to start a new chat with. It should summarize the issue we are working on, mentioning related files, things we have tried etc. And mention the actual main issue that let us to this side-track too
- try to make as little assumptions as possible. Best is to always verify an assumption. And if its disproven, that tells as just as much! If you feel you have to make a rather big assuption, or already made several smaller ones, ask the user for advise on how to handle this. Often the user can provide additional information.
- if you notice that the message from the user are getting shorter and shorter, that doesn't mean that you should also reduce your output. It just means the user is tired of repeating themselves and also entrusting you "to do your job" as best as you possibly can.
- If you think that for a given issue it would be helpful to get specific input by the user (for example by them running an sql query in supabase, or providing the log outputs etc.), ask for it
- you have the tendency to provide not only the "next step" but the next 3-5 steps when working on an issue. That is often times very helpful. But very often there is one logical next step to maybe validata an hypotheses, and based on the result of this first step, the next steps can be defined. Often times, this first logical step is running a command (either one you can run yourself, then just do it, or one that needs the user to run it and provide the output of that). The result of this often times have a big influence on what the next logical step would be. In these cases, focus on just the first step and ask the user to run whatever that command is (you of course provide it). Avoid providing more then this first step in these cases.
- sometimes a bold move can be the one option that brings us closer to an result. I That might involve deleting a file or even several. In such cases, suggest that to the user. The user can make a GitHub commit where they could revert to in case the app crashes in an unexpected way after implementation. Example for this: "We made some changes to a specific app component and we don't get the expected result. According to standard practice, we add a log to find out what's going on. Now the log also doesn't show up (or in an totally unexpected way), chances are, that the file is not the one we though as being responsible for the action we are focusing right now. Then the next logical step is to check if we stumbled on legacy code or even a legacy file. Since we are in a heavly AI-assisted coding situation (the user is not a programmer and has almost zero knowledge of web coding), there is a lot of legacy code around. The file might not be in use by any (functioning) part of our code. You can find that out by using your abilities. If you are sure its not in use, we can then safely delete the file. The user should then test the app and report back." This was the example.
- if we added specific logs just for debugging, we should actually often times delete the entries afterwards. Even though we have a highly custamizable log manager, it often just doesn't make sense to keep certain logs in the app. In those cases, delete them.
- You might even come across lo entries like that in the code base - entries, that have been "forgotten" and should actually be deleted. In those cases, confirm with the user first.

# Meta-Level
In bug fixing, like in medicine, we have to treat the cause, not fix the symptoms. Thats very important and has a direct influence on the way you answer in a chat. We are in a "work environment" that is very different from "normal, spoken language between humans, where you sometimes dive into sub-levels and drift off - because thats human and as an llm you have been trained on "being kind and most human-like". But for coding, things are different and much more black-and white. There are no maybies. Every behaviour the app has can in priciple be derived off the code - to which you have full access. Of cause, you can't save all the files of the database into your "memory", neither can you simulate the complete app behaviour within a chat like this. But you do can connect a few steps together. And you can also decide on when to respond in which way (the coding-oriented or the human-interaction way - based on the given context). Just make sure not to mix both approaches within one single part of a response.


The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with this locale configuration:
  provider:    libc
  LC_COLLATE:  C.UTF-8
  LC_CTYPE:    en_US.UTF-8
  LC_MESSAGES: en_US.UTF-8
  LC_MONETARY: en_US.UTF-8
  LC_NUMERIC:  en_US.UTF-8
  LC_TIME:     en_US.UTF-8
The default database encoding has accordingly been set to "UTF8".
The default text search configuration will be set to "english".

Data page checksums are disabled.

fixing permissions on existing directory /var/lib/postgresql/data ... ok
creating subdirectories ... ok
selecting dynamic shared memory implementation ... posix
selecting default max_connections ... 100
selecting default shared_buffers ... 128MB
selecting default time zone ... Etc/UTC
creating configuration files ... ok
running bootstrap script ... ok
performing post-bootstrap initialization ... ok
syncing data to disk ... ok


Success. You can now start the database server using:

    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start

waiting for server to start.... 2025-04-13 14:47:53.980 UTC [54] LOG:  pgaudit extension initialized
 2025-04-13 14:47:53.998 UTC [54] LOG:  pgsodium primary server secret key loaded
 2025-04-13 14:47:54.028 UTC [54] LOG:  starting PostgreSQL 15.8 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 13.2.0, 64-bit
 2025-04-13 14:47:54.030 UTC [54] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
 2025-04-13 14:47:54.036 UTC [60] LOG:  database system was shut down at 2025-04-13 14:47:53 UTC
 2025-04-13 14:47:54.043 UTC [54] LOG:  database system is ready to accept connections
 2025-04-13 14:47:54.043 UTC [63] LOG:  TimescaleDB background worker launcher connected to shared catalogs
 2025-04-13 14:47:54.045 UTC [65] LOG:  pg_cron scheduler started
 done
server started

/usr/local/bin/docker-entrypoint.sh: ignoring /docker-entrypoint-initdb.d/init-scripts

/usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/migrate.sh
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/init-scripts/00-schema.sql
[local] 2025-04-13 14:47:54.103 UTC [77] postgres@postgres LOG:  statement: CREATE USER pgbouncer;
CREATE ROLE
[local] 2025-04-13 14:47:54.103 UTC [77] postgres@postgres LOG:  statement: REVOKE ALL PRIVILEGES ON SCHEMA public FROM pgbouncer;
REVOKE
[local] 2025-04-13 14:47:54.104 UTC [77] postgres@postgres LOG:  statement: CREATE SCHEMA pgbouncer AUTHORIZATION pgbouncer;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.105 UTC [77] postgres@postgres LOG:  statement: CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename TEXT)
	RETURNS TABLE(username TEXT, password TEXT) AS
	$$
	BEGIN
	    RAISE WARNING 'PgBouncer auth request: %', p_usename;
	
	    RETURN QUERY
	    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow
	    WHERE usename = p_usename;
	END;
	$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.106 UTC [77] postgres@postgres LOG:  statement: REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename TEXT) FROM PUBLIC;
REVOKE
[local] 2025-04-13 14:47:54.107 UTC [77] postgres@postgres LOG:  statement: GRANT EXECUTE ON FUNCTION pgbouncer.get_auth(p_usename TEXT) TO pgbouncer;
GRANT
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/init-scripts/00000000000000-initial-schema.sql
[local] 2025-04-13 14:47:54.112 UTC [79] postgres@postgres LOG:  statement: create publication supabase_realtime;
CREATE PUBLICATION
[local] 2025-04-13 14:47:54.114 UTC [79] postgres@postgres LOG:  statement: alter user  supabase_admin with superuser createdb createrole replication bypassrls;
ALTER ROLE
[local] 2025-04-13 14:47:54.114 UTC [79] postgres@postgres LOG:  statement: create user supabase_replication_admin with login replication;
CREATE ROLE
[local] 2025-04-13 14:47:54.115 UTC [79] postgres@postgres LOG:  statement: create role supabase_read_only_user with login bypassrls;
CREATE ROLE
[local] 2025-04-13 14:47:54.116 UTC [79] postgres@postgres LOG:  statement: grant pg_read_all_data to supabase_read_only_user;
GRANT ROLE
[local] 2025-04-13 14:47:54.117 UTC [79] postgres@postgres LOG:  statement: create schema if not exists extensions;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.118 UTC [79] postgres@postgres LOG:  statement: create extension if not exists "uuid-ossp"      with schema extensions;
CREATE EXTENSION
[local] 2025-04-13 14:47:54.123 UTC [79] postgres@postgres LOG:  statement: create extension if not exists pgcrypto         with schema extensions;
CREATE EXTENSION
[local] 2025-04-13 14:47:54.129 UTC [79] postgres@postgres LOG:  statement: create extension if not exists pgjwt            with schema extensions;
CREATE EXTENSION
[local] 2025-04-13 14:47:54.135 UTC [79] postgres@postgres LOG:  statement: create role anon                nologin noinherit;
CREATE ROLE
[local] 2025-04-13 14:47:54.136 UTC [79] postgres@postgres LOG:  statement: create role authenticated       nologin noinherit;
CREATE ROLE
[local] 2025-04-13 14:47:54.137 UTC [79] postgres@postgres LOG:  statement: create role service_role        nologin noinherit bypassrls;
CREATE ROLE
[local] 2025-04-13 14:47:54.138 UTC [79] postgres@postgres LOG:  statement: create user authenticator noinherit;
CREATE ROLE
[local] 2025-04-13 14:47:54.139 UTC [79] postgres@postgres LOG:  statement: grant anon              to authenticator;
GRANT ROLE
[local] 2025-04-13 14:47:54.140 UTC [79] postgres@postgres LOG:  statement: grant authenticated     to authenticator;
GRANT ROLE
[local] 2025-04-13 14:47:54.141 UTC [79] postgres@postgres LOG:  statement: grant service_role      to authenticator;
GRANT ROLE
[local] 2025-04-13 14:47:54.142 UTC [79] postgres@postgres LOG:  statement: grant supabase_admin    to authenticator;
GRANT ROLE
[local] 2025-04-13 14:47:54.142 UTC [79] postgres@postgres LOG:  statement: grant usage                     on schema public to postgres, anon, authenticated, service_role;
GRANT
[local] 2025-04-13 14:47:54.143 UTC [79] postgres@postgres LOG:  statement: alter default privileges in schema public grant all on tables to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.144 UTC [79] postgres@postgres LOG:  statement: alter default privileges in schema public grant all on functions to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.145 UTC [79] postgres@postgres LOG:  statement: alter default privileges in schema public grant all on sequences to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.146 UTC [79] postgres@postgres LOG:  statement: grant usage                     on schema extensions to postgres, anon, authenticated, service_role;
GRANT
[local] 2025-04-13 14:47:54.147 UTC [79] postgres@postgres LOG:  statement: alter user supabase_admin SET search_path TO public, extensions;
ALTER ROLE
[local] 2025-04-13 14:47:54.148 UTC [79] postgres@postgres LOG:  statement: alter default privileges for user supabase_admin in schema public grant all
	    on sequences to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.149 UTC [79] postgres@postgres LOG:  statement: alter default privileges for user supabase_admin in schema public grant all
	    on tables to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.149 UTC [79] postgres@postgres LOG:  statement: alter default privileges for user supabase_admin in schema public grant all
	    on functions to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.151 UTC [79] postgres@postgres LOG:  statement: alter role anon set statement_timeout = '3s';
ALTER ROLE
[local] 2025-04-13 14:47:54.151 UTC [79] postgres@postgres LOG:  statement: alter role authenticated set statement_timeout = '8s';
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/init-scripts/00000000000001-auth-schema.sql
[local] 2025-04-13 14:47:54.156 UTC [81] postgres@postgres LOG:  statement: CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION supabase_admin;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.157 UTC [81] postgres@postgres LOG:  statement: CREATE TABLE auth.users (
	    instance_id uuid NULL,
	    id uuid NOT NULL UNIQUE,
	    aud varchar(255) NULL,
	    "role" varchar(255) NULL,
	    email varchar(255) NULL UNIQUE,
	    encrypted_password varchar(255) NULL,
	    confirmed_at timestamptz NULL,
	    invited_at timestamptz NULL,
	    confirmation_token varchar(255) NULL,
	    confirmation_sent_at timestamptz NULL,
	    recovery_token varchar(255) NULL,
	    recovery_sent_at timestamptz NULL,
	    email_change_token varchar(255) NULL,
	    email_change varchar(255) NULL,
	    email_change_sent_at timestamptz NULL,
	    last_sign_in_at timestamptz NULL,
	    raw_app_meta_data jsonb NULL,
	    raw_user_meta_data jsonb NULL,
	    is_super_admin bool NULL,
	    created_at timestamptz NULL,
	    updated_at timestamptz NULL,
	    CONSTRAINT users_pkey PRIMARY KEY (id)
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.168 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, email);
CREATE INDEX
[local] 2025-04-13 14:47:54.171 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);
CREATE INDEX
[local] 2025-04-13 14:47:54.175 UTC [81] postgres@postgres LOG:  statement: comment on table auth.users is 'Auth: Stores user login data within a secure schema.';
COMMENT
[local] 2025-04-13 14:47:54.176 UTC [81] postgres@postgres LOG:  statement: CREATE TABLE auth.refresh_tokens (
	    instance_id uuid NULL,
	    id bigserial NOT NULL,
	    "token" varchar(255) NULL,
	    user_id varchar(255) NULL,
	    revoked bool NULL,
	    created_at timestamptz NULL,
	    updated_at timestamptz NULL,
	    CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id)
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.182 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);
CREATE INDEX
[local] 2025-04-13 14:47:54.185 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);
CREATE INDEX
[local] 2025-04-13 14:47:54.189 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX refresh_tokens_token_idx ON auth.refresh_tokens USING btree (token);
CREATE INDEX
[local] 2025-04-13 14:47:54.192 UTC [81] postgres@postgres LOG:  statement: comment on table auth.refresh_tokens is 'Auth: Store of tokens used to refresh JWT tokens once they expire.';
COMMENT
[local] 2025-04-13 14:47:54.193 UTC [81] postgres@postgres LOG:  statement: CREATE TABLE auth.instances (
	    id uuid NOT NULL,
	    uuid uuid NULL,
	    raw_base_config text NULL,
	    created_at timestamptz NULL,
	    updated_at timestamptz NULL,
	    CONSTRAINT instances_pkey PRIMARY KEY (id)
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.199 UTC [81] postgres@postgres LOG:  statement: comment on table auth.instances is 'Auth: Manages users across multiple sites.';
COMMENT
[local] 2025-04-13 14:47:54.200 UTC [81] postgres@postgres LOG:  statement: CREATE TABLE auth.audit_log_entries (
	    instance_id uuid NULL,
	    id uuid NOT NULL,
	    payload json NULL,
	    created_at timestamptz NULL,
	    CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id)
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.205 UTC [81] postgres@postgres LOG:  statement: CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);
CREATE INDEX
[local] 2025-04-13 14:47:54.208 UTC [81] postgres@postgres LOG:  statement: comment on table auth.audit_log_entries is 'Auth: Audit trail for user actions.';
COMMENT
[local] 2025-04-13 14:47:54.209 UTC [81] postgres@postgres LOG:  statement: CREATE TABLE auth.schema_migrations (
	    "version" varchar(255) NOT NULL,
	    CONSTRAINT schema_migrations_pkey PRIMARY KEY ("version")
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.213 UTC [81] postgres@postgres LOG:  statement: comment on table auth.schema_migrations is 'Auth: Manages updates to the auth system.';
COMMENT
INSERT 0 7
[local] 2025-04-13 14:47:54.215 UTC [81] postgres@postgres LOG:  statement: create or replace function auth.uid() returns uuid as $$
	  select nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;
	$$ language sql stable;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.217 UTC [81] postgres@postgres LOG:  statement: create or replace function auth.role() returns text as $$
	  select nullif(current_setting('request.jwt.claim.role', true), '')::text;
	$$ language sql stable;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.218 UTC [81] postgres@postgres LOG:  statement: create or replace function auth.email() returns text as $$
	  select nullif(current_setting('request.jwt.claim.email', true), '')::text;
	$$ language sql stable;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.219 UTC [81] postgres@postgres LOG:  statement: GRANT USAGE ON SCHEMA auth TO anon, authenticated, service_role;
GRANT
[local] 2025-04-13 14:47:54.220 UTC [81] postgres@postgres LOG:  statement: CREATE USER supabase_auth_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
CREATE ROLE
[local] 2025-04-13 14:47:54.221 UTC [81] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.221 UTC [81] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.222 UTC [81] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.223 UTC [81] postgres@postgres LOG:  statement: ALTER USER supabase_auth_admin SET search_path = "auth";
ALTER ROLE
[local] 2025-04-13 14:47:54.224 UTC [81] postgres@postgres LOG:  statement: ALTER table "auth".users OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.225 UTC [81] postgres@postgres LOG:  statement: ALTER table "auth".refresh_tokens OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.227 UTC [81] postgres@postgres LOG:  statement: ALTER table "auth".audit_log_entries OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.228 UTC [81] postgres@postgres LOG:  statement: ALTER table "auth".instances OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.229 UTC [81] postgres@postgres LOG:  statement: ALTER table "auth".schema_migrations OWNER TO supabase_auth_admin;
ALTER TABLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/init-scripts/00000000000002-storage-schema.sql
[local] 2025-04-13 14:47:54.233 UTC [83] postgres@postgres LOG:  statement: CREATE SCHEMA IF NOT EXISTS storage AUTHORIZATION supabase_admin;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.234 UTC [83] postgres@postgres LOG:  statement: grant usage on schema storage to postgres, anon, authenticated, service_role;
GRANT
[local] 2025-04-13 14:47:54.236 UTC [83] postgres@postgres LOG:  statement: alter default privileges in schema storage grant all on tables to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.236 UTC [83] postgres@postgres LOG:  statement: alter default privileges in schema storage grant all on functions to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.237 UTC [83] postgres@postgres LOG:  statement: alter default privileges in schema storage grant all on sequences to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.238 UTC [83] postgres@postgres LOG:  statement: CREATE TABLE "storage"."buckets" (
	    "id" text not NULL,
	    "name" text NOT NULL,
	    "owner" uuid,
	    "created_at" timestamptz DEFAULT now(),
	    "updated_at" timestamptz DEFAULT now(),
	    CONSTRAINT "buckets_owner_fkey" FOREIGN KEY ("owner") REFERENCES "auth"."users"("id"),
	    PRIMARY KEY ("id")
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.245 UTC [83] postgres@postgres LOG:  statement: CREATE UNIQUE INDEX "bname" ON "storage"."buckets" USING BTREE ("name");
CREATE INDEX
[local] 2025-04-13 14:47:54.248 UTC [83] postgres@postgres LOG:  statement: CREATE TABLE "storage"."objects" (
	    "id" uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
	    "bucket_id" text,
	    "name" text,
	    "owner" uuid,
	    "created_at" timestamptz DEFAULT now(),
	    "updated_at" timestamptz DEFAULT now(),
	    "last_accessed_at" timestamptz DEFAULT now(),
	    "metadata" jsonb,
	    CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY ("bucket_id") REFERENCES "storage"."buckets"("id"),
	    CONSTRAINT "objects_owner_fkey" FOREIGN KEY ("owner") REFERENCES "auth"."users"("id"),
	    PRIMARY KEY ("id")
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.255 UTC [83] postgres@postgres LOG:  statement: CREATE UNIQUE INDEX "bucketid_objname" ON "storage"."objects" USING BTREE ("bucket_id","name");
CREATE INDEX
[local] 2025-04-13 14:47:54.257 UTC [83] postgres@postgres LOG:  statement: CREATE INDEX name_prefix_search ON storage.objects(name text_pattern_ops);
CREATE INDEX
[local] 2025-04-13 14:47:54.261 UTC [83] postgres@postgres LOG:  statement: ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;
ALTER TABLE
[local] 2025-04-13 14:47:54.262 UTC [83] postgres@postgres LOG:  statement: CREATE FUNCTION storage.foldername(name text)
	 RETURNS text[]
	 LANGUAGE plpgsql
	AS $function$
	DECLARE
	_parts text[];
	BEGIN
	    select string_to_array(name, '/') into _parts;
	    return _parts[1:array_length(_parts,1)-1];
	END
	$function$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.263 UTC [83] postgres@postgres LOG:  statement: CREATE FUNCTION storage.filename(name text)
	 RETURNS text
	 LANGUAGE plpgsql
	AS $function$
	DECLARE
	_parts text[];
	BEGIN
	    select string_to_array(name, '/') into _parts;
	    return _parts[array_length(_parts,1)];
	END
	$function$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.264 UTC [83] postgres@postgres LOG:  statement: CREATE FUNCTION storage.extension(name text)
	 RETURNS text
	 LANGUAGE plpgsql
	AS $function$
	DECLARE
	_parts text[];
	_filename text;
	BEGIN
	    select string_to_array(name, '/') into _parts;
	    select _parts[array_length(_parts,1)] into _filename;
	    -- @todo return the last part instead of 2
	    return split_part(_filename, '.', 2);
	END
	$function$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.265 UTC [83] postgres@postgres LOG:  statement: CREATE FUNCTION storage.search(prefix text, bucketname text, limits int DEFAULT 100, levels int DEFAULT 1, offsets int DEFAULT 0)
	 RETURNS TABLE (
	    name text,
	    id uuid,
	    updated_at TIMESTAMPTZ,
	    created_at TIMESTAMPTZ,
	    last_accessed_at TIMESTAMPTZ,
	    metadata jsonb
	  )
	 LANGUAGE plpgsql
	AS $function$
	DECLARE
	_bucketId text;
	BEGIN
	    -- will be replaced by migrations when server starts
	    -- saving space for cloud-init
	END
	$function$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.267 UTC [83] postgres@postgres LOG:  statement: CREATE TABLE IF NOT EXISTS storage.migrations (
	  id integer PRIMARY KEY,
	  name varchar(100) UNIQUE NOT NULL,
	  hash varchar(40) NOT NULL, -- sha1 hex encoded hash of the file name and contents, to ensure it hasn't been altered since applying the migration
	  executed_at timestamp DEFAULT current_timestamp
	);
CREATE TABLE
[local] 2025-04-13 14:47:54.274 UTC [83] postgres@postgres LOG:  statement: CREATE USER supabase_storage_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
CREATE ROLE
[local] 2025-04-13 14:47:54.275 UTC [83] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON SCHEMA storage TO supabase_storage_admin;
GRANT
[local] 2025-04-13 14:47:54.276 UTC [83] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA storage TO supabase_storage_admin;
GRANT
[local] 2025-04-13 14:47:54.277 UTC [83] postgres@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA storage TO supabase_storage_admin;
GRANT
[local] 2025-04-13 14:47:54.277 UTC [83] postgres@postgres LOG:  statement: ALTER USER supabase_storage_admin SET search_path = "storage";
ALTER ROLE
[local] 2025-04-13 14:47:54.278 UTC [83] postgres@postgres LOG:  statement: ALTER table "storage".objects owner to supabase_storage_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.280 UTC [83] postgres@postgres LOG:  statement: ALTER table "storage".buckets owner to supabase_storage_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.280 UTC [83] postgres@postgres LOG:  statement: ALTER table "storage".migrations OWNER TO supabase_storage_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.281 UTC [83] postgres@postgres LOG:  statement: ALTER function "storage".foldername(text) owner to supabase_storage_admin;
ALTER FUNCTION
[local] 2025-04-13 14:47:54.282 UTC [83] postgres@postgres LOG:  statement: ALTER function "storage".filename(text) owner to supabase_storage_admin;
ALTER FUNCTION
[local] 2025-04-13 14:47:54.283 UTC [83] postgres@postgres LOG:  statement: ALTER function "storage".extension(text) owner to supabase_storage_admin;
ALTER FUNCTION
[local] 2025-04-13 14:47:54.284 UTC [83] postgres@postgres LOG:  statement: ALTER function "storage".search(text,text,int,int,int) owner to supabase_storage_admin;
ALTER FUNCTION
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/init-scripts/00000000000003-post-setup.sql
[local] 2025-04-13 14:47:54.290 UTC [85] postgres@postgres LOG:  statement: ALTER ROLE supabase_admin SET search_path TO "\$user",public,auth,extensions;
ALTER ROLE
[local] 2025-04-13 14:47:54.290 UTC [85] postgres@postgres LOG:  statement: ALTER ROLE postgres SET search_path TO "\$user",public,extensions;
ALTER ROLE
[local] 2025-04-13 14:47:54.291 UTC [85] postgres@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()
	RETURNS event_trigger
	LANGUAGE plpgsql
	AS $$
	DECLARE
	  schema_is_cron bool;
	BEGIN
	  schema_is_cron = (
	    SELECT n.nspname = 'cron'
	    FROM pg_event_trigger_ddl_commands() AS ev
	    LEFT JOIN pg_catalog.pg_namespace AS n
	      ON ev.objid = n.oid
	  );
	
	  IF schema_is_cron
	  THEN
	    grant usage on schema cron to postgres with grant option;
	
	    alter default privileges in schema cron grant all on tables to postgres with grant option;
	    alter default privileges in schema cron grant all on functions to postgres with grant option;
	    alter default privileges in schema cron grant all on sequences to postgres with grant option;
	
	    alter default privileges for user supabase_admin in schema cron grant all
	        on sequences to postgres with grant option;
	    alter default privileges for user supabase_admin in schema cron grant all
	        on tables to postgres with grant option;
	    alter default privileges for user supabase_admin in schema cron grant all
	        on functions to postgres with grant option;
	
	    grant all privileges on all tables in schema cron to postgres with grant option;
	
	  END IF;
	
	END;
	$$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.293 UTC [85] postgres@postgres LOG:  statement: CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end WHEN TAG in ('CREATE SCHEMA')
	EXECUTE PROCEDURE extensions.grant_pg_cron_access();
CREATE EVENT TRIGGER
[local] 2025-04-13 14:47:54.294 UTC [85] postgres@postgres LOG:  statement: COMMENT ON FUNCTION extensions.grant_pg_cron_access IS 'Grants access to pg_cron';
COMMENT
[local] 2025-04-13 14:47:54.294 UTC [85] postgres@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
	RETURNS event_trigger
	LANGUAGE plpgsql
	AS $$
	BEGIN
	  IF EXISTS (
	    SELECT 1
	    FROM pg_event_trigger_ddl_commands() AS ev
	    JOIN pg_extension AS ext
	    ON ev.objid = ext.oid
	    WHERE ext.extname = 'pg_net'
	  )
	  THEN
	    IF NOT EXISTS (
	      SELECT 1
	      FROM pg_roles
	      WHERE rolname = 'supabase_functions_admin'
	    )
	    THEN
	      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
	    END IF;
	
	    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;
	
	    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
	    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
	
	    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
	    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
	
	    REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
	    REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
	
	    GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
	    GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
	  END IF;
	END;
	$$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.296 UTC [85] postgres@postgres LOG:  statement: COMMENT ON FUNCTION extensions.grant_pg_net_access IS 'Grants access to pg_net';
COMMENT
DO
[local] 2025-04-13 14:47:54.298 UTC [85] postgres@postgres LOG:  statement: CREATE ROLE dashboard_user NOSUPERUSER CREATEDB CREATEROLE REPLICATION;
CREATE ROLE
[local] 2025-04-13 14:47:54.299 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON DATABASE postgres TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.300 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON SCHEMA auth TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.301 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON SCHEMA extensions TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.302 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON SCHEMA storage TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.303 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA auth TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.304 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA extensions TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.304 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.305 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.305 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA extensions TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.305 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.306 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA storage TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.308 UTC [85] postgres@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA extensions TO dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.313 UTC [87] postgres@postgres LOG:  statement: ALTER USER supabase_admin WITH PASSWORD 'postgres'
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/00-extension.sql
[local] 2025-04-13 14:47:54.325 UTC [89] supabase_admin@postgres LOG:  statement: CREATE SCHEMA IF NOT exists extensions;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.326 UTC [89] supabase_admin@postgres LOG:  statement: CREATE EXTENSION IF NOT EXISTS pg_stat_statements with schema extensions;
CREATE EXTENSION
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/10000000000000_demote-postgres.sql
[local] 2025-04-13 14:47:54.344 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON DATABASE postgres TO postgres;
GRANT
[local] 2025-04-13 14:47:54.345 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON SCHEMA auth TO postgres;
GRANT
[local] 2025-04-13 14:47:54.346 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON SCHEMA extensions TO postgres;
GRANT
[local] 2025-04-13 14:47:54.347 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON SCHEMA storage TO postgres;
GRANT
[local] 2025-04-13 14:47:54.348 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA auth TO postgres;
GRANT
[local] 2025-04-13 14:47:54.349 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA storage TO postgres;
GRANT
[local] 2025-04-13 14:47:54.350 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA extensions TO postgres;
GRANT
[local] 2025-04-13 14:47:54.352 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO postgres;
GRANT
[local] 2025-04-13 14:47:54.353 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO postgres;
GRANT
[local] 2025-04-13 14:47:54.353 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA extensions TO postgres;
GRANT
[local] 2025-04-13 14:47:54.353 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO postgres;
GRANT
[local] 2025-04-13 14:47:54.354 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA storage TO postgres;
GRANT
[local] 2025-04-13 14:47:54.355 UTC [91] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA extensions TO postgres;
GRANT
[local] 2025-04-13 14:47:54.357 UTC [91] supabase_admin@postgres LOG:  statement: ALTER ROLE postgres NOSUPERUSER CREATEDB CREATEROLE LOGIN REPLICATION BYPASSRLS;
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20211115181400_update-auth-permissions.sql
[local] 2025-04-13 14:47:54.365 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL PRIVILEGES ON SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.366 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.367 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA auth TO supabase_auth_admin;
GRANT
[local] 2025-04-13 14:47:54.368 UTC [93] supabase_admin@postgres LOG:  statement: ALTER table IF EXISTS "auth".users OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.369 UTC [93] supabase_admin@postgres LOG:  statement: ALTER table IF EXISTS "auth".refresh_tokens OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.370 UTC [93] supabase_admin@postgres LOG:  statement: ALTER table IF EXISTS "auth".audit_log_entries OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.371 UTC [93] supabase_admin@postgres LOG:  statement: ALTER table IF EXISTS "auth".instances OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.372 UTC [93] supabase_admin@postgres LOG:  statement: ALTER table IF EXISTS "auth".schema_migrations OWNER TO supabase_auth_admin;
ALTER TABLE
[local] 2025-04-13 14:47:54.373 UTC [93] supabase_admin@postgres LOG:  statement: GRANT USAGE ON SCHEMA auth TO postgres;
GRANT
[local] 2025-04-13 14:47:54.374 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA auth TO postgres, dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.375 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO postgres, dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.376 UTC [93] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO postgres, dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.377 UTC [93] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.378 UTC [93] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.379 UTC [93] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON ROUTINES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20211118015519_create-realtime-schema.sql
[local] 2025-04-13 14:47:54.388 UTC [95] supabase_admin@postgres LOG:  statement: CREATE SCHEMA IF NOT EXISTS realtime;
CREATE SCHEMA
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20211122051245_update-realtime-permissions.sql
[local] 2025-04-13 14:47:54.397 UTC [97] supabase_admin@postgres LOG:  statement: GRANT USAGE ON SCHEMA realtime TO postgres;
GRANT
[local] 2025-04-13 14:47:54.398 UTC [97] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL TABLES IN SCHEMA realtime TO postgres, dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.398 UTC [97] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL SEQUENCES IN SCHEMA realtime TO postgres, dashboard_user;
GRANT
[local] 2025-04-13 14:47:54.398 UTC [97] supabase_admin@postgres LOG:  statement: GRANT ALL ON ALL ROUTINES IN SCHEMA realtime TO postgres, dashboard_user;
GRANT
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20211124212715_update-auth-owner.sql
DO
DO
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20211130151719_update-realtime-permissions.sql
[local] 2025-04-13 14:47:54.419 UTC [101] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.420 UTC [101] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.421 UTC [101] supabase_admin@postgres LOG:  statement: ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON ROUTINES TO postgres, dashboard_user;
ALTER DEFAULT PRIVILEGES
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220118070449_enable-safeupdate-postgrest.sql
[local] 2025-04-13 14:47:54.430 UTC [103] supabase_admin@postgres LOG:  statement: ALTER ROLE authenticator SET session_preload_libraries = 'safeupdate';
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220126121436_finer-postgrest-triggers.sql
[local] 2025-04-13 14:47:54.439 UTC [105] supabase_admin@postgres LOG:  statement: drop event trigger if exists api_restart;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.439 UTC [105] supabase_admin@postgres LOG:  statement: drop function if exists extensions.notify_api_restart();
DROP FUNCTION
[local] 2025-04-13 14:47:54.439 UTC [105] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger AS $$
	DECLARE
	  cmd record;
	BEGIN
	  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
	  LOOP
	    IF cmd.command_tag IN (
	      'CREATE SCHEMA', 'ALTER SCHEMA'
	    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
	    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
	    , 'CREATE VIEW', 'ALTER VIEW'
	    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
	    , 'CREATE FUNCTION', 'ALTER FUNCTION'
	    , 'CREATE TRIGGER'
	    , 'CREATE TYPE'
	    , 'CREATE RULE'
	    , 'COMMENT'
	    )
	    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
	    AND cmd.schema_name is distinct from 'pg_temp'
	    THEN
	      NOTIFY pgrst, 'reload schema';
	    END IF;
	  END LOOP;
	END; $$ LANGUAGE plpgsql;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.440 UTC [105] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger AS $$
	DECLARE
	  obj record;
	BEGIN
	  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
	  LOOP
	    IF obj.object_type IN (
	      'schema'
	    , 'table'
	    , 'foreign table'
	    , 'view'
	    , 'materialized view'
	    , 'function'
	    , 'trigger'
	    , 'type'
	    , 'rule'
	    )
	    AND obj.is_temporary IS false -- no pg_temp objects
	    THEN
	      NOTIFY pgrst, 'reload schema';
	    END IF;
	  END LOOP;
	END; $$ LANGUAGE plpgsql;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.442 UTC [105] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS pgrst_ddl_watch;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.442 UTC [105] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER pgrst_ddl_watch
	  ON ddl_command_end
	  EXECUTE PROCEDURE extensions.pgrst_ddl_watch();
CREATE EVENT TRIGGER
[local] 2025-04-13 14:47:54.443 UTC [105] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS pgrst_drop_watch;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.443 UTC [105] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER pgrst_drop_watch
	  ON sql_drop
	  EXECUTE PROCEDURE extensions.pgrst_drop_watch();
CREATE EVENT TRIGGER
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220224211803_fix-postgrest-supautils.sql
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220317095840_pg_graphql.sql
[local] 2025-04-13 14:47:54.494 UTC [109] supabase_admin@postgres LOG:  statement: create schema if not exists graphql_public;
CREATE SCHEMA
[local] 2025-04-13 14:47:54.496 UTC [109] supabase_admin@postgres LOG:  statement: drop function if exists graphql_public.graphql(text, text, jsonb);
DROP FUNCTION
[local] 2025-04-13 14:47:54.496 UTC [109] supabase_admin@postgres LOG:  statement: create or replace function graphql_public.graphql(
	    "operationName" text default null,
	    query text default null,
	    variables jsonb default null,
	    extensions jsonb default null
	)
	    returns jsonb
	    language plpgsql
	as $$
	    DECLARE
	        server_version float;
	    BEGIN
	        server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);
	
	        IF server_version >= 14 THEN
	            RETURN jsonb_build_object(
	                'data', null::jsonb,
	                'errors', array['pg_graphql extension is not enabled.']
	            );
	        ELSE
	            RETURN jsonb_build_object(
	                'data', null::jsonb,
	                'errors', array['pg_graphql is only available on projects running Postgres 14 onwards.']
	            );
	        END IF;
	    END;
	$$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.497 UTC [109] supabase_admin@postgres LOG:  statement: grant usage on schema graphql_public to postgres, anon, authenticated, service_role;
GRANT
[local] 2025-04-13 14:47:54.499 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges in schema graphql_public grant all on tables to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.500 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges in schema graphql_public grant all on functions to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.501 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges in schema graphql_public grant all on sequences to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.503 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges for user supabase_admin in schema graphql_public grant all
	    on sequences to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.504 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges for user supabase_admin in schema graphql_public grant all
	    on tables to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.505 UTC [109] supabase_admin@postgres LOG:  statement: alter default privileges for user supabase_admin in schema graphql_public grant all
	    on functions to postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.506 UTC [109] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()
	RETURNS event_trigger
	LANGUAGE plpgsql
	AS $func$
	    DECLARE
	    func_is_graphql_resolve bool;
	    BEGIN
	    func_is_graphql_resolve = (
	        SELECT n.proname = 'resolve'
	        FROM pg_event_trigger_ddl_commands() AS ev
	        LEFT JOIN pg_catalog.pg_proc AS n
	        ON ev.objid = n.oid
	    );
	
	    IF func_is_graphql_resolve
	    THEN
	        grant usage on schema graphql to postgres, anon, authenticated, service_role;
	        grant all on function graphql.resolve to postgres, anon, authenticated, service_role;
	
	        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
	
	        DROP FUNCTION IF EXISTS graphql_public.graphql;
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language sql
	        as $$
	            SELECT graphql.resolve(query, coalesce(variables, '{}'));
	        $$;
	
	        grant execute on function graphql.resolve to postgres, anon, authenticated, service_role;
	    END IF;
	
	    END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.507 UTC [109] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS issue_pg_graphql_access;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.507 UTC [109] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end WHEN TAG in ('CREATE FUNCTION')
	EXECUTE PROCEDURE extensions.grant_pg_graphql_access();
CREATE EVENT TRIGGER
[local] 2025-04-13 14:47:54.507 UTC [109] supabase_admin@postgres LOG:  statement: COMMENT ON FUNCTION extensions.grant_pg_graphql_access IS 'Grants access to pg_graphql';
COMMENT
[local] 2025-04-13 14:47:54.508 UTC [109] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
	RETURNS event_trigger
	LANGUAGE plpgsql
	AS $func$
	    DECLARE
	    graphql_is_dropped bool;
	    BEGIN
	    graphql_is_dropped = (
	        SELECT ev.schema_name = 'graphql_public'
	        FROM pg_event_trigger_dropped_objects() AS ev
	        WHERE ev.schema_name = 'graphql_public'
	    );
	
	    IF graphql_is_dropped
	    THEN
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language plpgsql
	        as $$
	            DECLARE
	                server_version float;
	            BEGIN
	                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);
	
	                IF server_version >= 14 THEN
	                    RETURN jsonb_build_object(
	                        'data', null::jsonb,
	                        'errors', array['pg_graphql extension is not enabled.']
	                    );
	                ELSE
	                    RETURN jsonb_build_object(
	                        'data', null::jsonb,
	                        'errors', array['pg_graphql is only available on projects running Postgres 14 onwards.']
	                    );
	                END IF;
	            END;
	        $$;
	    END IF;
	
	    END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.510 UTC [109] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS issue_graphql_placeholder;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.510 UTC [109] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop WHEN TAG in ('DROP EXTENSION')
	EXECUTE PROCEDURE extensions.set_graphql_placeholder();
CREATE EVENT TRIGGER
[local] 2025-04-13 14:47:54.512 UTC [109] supabase_admin@postgres LOG:  statement: COMMENT ON FUNCTION extensions.set_graphql_placeholder IS 'Reintroduces placeholder function for graphql_public.graphql';
COMMENT
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220321174452_fix-postgrest-alter-type-event-trigger.sql
[local] 2025-04-13 14:47:54.521 UTC [111] supabase_admin@postgres LOG:  statement: drop event trigger if exists api_restart;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.521 UTC [111] supabase_admin@postgres LOG:  statement: drop function if exists extensions.notify_api_restart();
DROP FUNCTION
[local] 2025-04-13 14:47:54.521 UTC [111] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger AS $$
	DECLARE
	  cmd record;
	BEGIN
	  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
	  LOOP
	    IF cmd.command_tag IN (
	      'CREATE SCHEMA', 'ALTER SCHEMA'
	    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
	    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
	    , 'CREATE VIEW', 'ALTER VIEW'
	    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
	    , 'CREATE FUNCTION', 'ALTER FUNCTION'
	    , 'CREATE TRIGGER'
	    , 'CREATE TYPE', 'ALTER TYPE'
	    , 'CREATE RULE'
	    , 'COMMENT'
	    )
	    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
	    AND cmd.schema_name is distinct from 'pg_temp'
	    THEN
	      NOTIFY pgrst, 'reload schema';
	    END IF;
	  END LOOP;
	END; $$ LANGUAGE plpgsql;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.524 UTC [111] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger AS $$
	DECLARE
	  obj record;
	BEGIN
	  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
	  LOOP
	    IF obj.object_type IN (
	      'schema'
	    , 'table'
	    , 'foreign table'
	    , 'view'
	    , 'materialized view'
	    , 'function'
	    , 'trigger'
	    , 'type'
	    , 'rule'
	    )
	    AND obj.is_temporary IS false -- no pg_temp objects
	    THEN
	      NOTIFY pgrst, 'reload schema';
	    END IF;
	  END LOOP;
	END; $$ LANGUAGE plpgsql;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.525 UTC [111] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS pgrst_ddl_watch;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.527 UTC [111] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER pgrst_ddl_watch
	  ON ddl_command_end
	  EXECUTE PROCEDURE extensions.pgrst_ddl_watch();
CREATE EVENT TRIGGER
[local] 2025-04-13 14:47:54.528 UTC [111] supabase_admin@postgres LOG:  statement: DROP EVENT TRIGGER IF EXISTS pgrst_drop_watch;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.529 UTC [111] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER pgrst_drop_watch
	  ON sql_drop
	  EXECUTE PROCEDURE extensions.pgrst_drop_watch();
CREATE EVENT TRIGGER
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220322085208_gotrue-session-limit.sql
[local] 2025-04-13 14:47:54.538 UTC [113] supabase_admin@postgres LOG:  statement: ALTER ROLE supabase_auth_admin SET idle_in_transaction_session_timeout TO 60000;
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220404205710_pg_graphql-on-by-default.sql
[local] 2025-04-13 14:47:54.546 UTC [115] supabase_admin@postgres LOG:  statement: create or replace function extensions.grant_pg_graphql_access()
	    returns event_trigger
	    language plpgsql
	AS $func$
	DECLARE
	    func_is_graphql_resolve bool;
	BEGIN
	    func_is_graphql_resolve = (
	        SELECT n.proname = 'resolve'
	        FROM pg_event_trigger_ddl_commands() AS ev
	        LEFT JOIN pg_catalog.pg_proc AS n
	        ON ev.objid = n.oid
	    );
	
	    IF func_is_graphql_resolve
	    THEN
	        grant usage on schema graphql to postgres, anon, authenticated, service_role;
	        grant all on function graphql.resolve to postgres, anon, authenticated, service_role;
	
	        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
	
	        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
	        DROP FUNCTION IF EXISTS graphql_public.graphql;
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language sql
	        as $$
	            -- This changed
	            select graphql.resolve(
	                query := query,
	                variables := coalesce(variables, '{}'),
	                "operationName" := "operationName",
	                extensions := extensions
	            );
	        $$;
	
	        grant execute on function graphql.resolve to postgres, anon, authenticated, service_role;
	    END IF;
	
	END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.549 UTC [115] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
	RETURNS event_trigger
	LANGUAGE plpgsql
	AS $func$
	    DECLARE
	    graphql_is_dropped bool;
	    BEGIN
	    graphql_is_dropped = (
	        SELECT ev.schema_name = 'graphql_public'
	        FROM pg_event_trigger_dropped_objects() AS ev
	        WHERE ev.schema_name = 'graphql_public'
	    );
	
	    IF graphql_is_dropped
	    THEN
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language plpgsql
	        as $$
	            DECLARE
	                server_version float;
	            BEGIN
	                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);
	
	                IF server_version >= 14 THEN
	                    RETURN jsonb_build_object(
	                        'errors', jsonb_build_array(
	                            jsonb_build_object(
	                                'message', 'pg_graphql extension is not enabled.'
	                            )
	                        )
	                    );
	                ELSE
	                    RETURN jsonb_build_object(
	                        'errors', jsonb_build_array(
	                            jsonb_build_object(
	                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
	                            )
	                        )
	                    );
	                END IF;
	            END;
	        $$;
	    END IF;
	
	    END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.550 UTC [115] supabase_admin@postgres LOG:  statement: create or replace function graphql_public.graphql(
	    "operationName" text default null,
	    query text default null,
	    variables jsonb default null,
	    extensions jsonb default null
	)
	    returns jsonb
	    language plpgsql
	as $$
	    DECLARE
	        server_version float;
	    BEGIN
	        server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);
	
	        IF server_version >= 14 THEN
	            RETURN jsonb_build_object(
	                'errors', jsonb_build_array(
	                    jsonb_build_object(
	                        'message', 'pg_graphql extension is not enabled.'
	                    )
	                )
	            );
	        ELSE
	            RETURN jsonb_build_object(
	                'errors', jsonb_build_array(
	                    jsonb_build_object(
	                        'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
	                    )
	                )
	            );
	        END IF;
	    END;
	$$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.551 UTC [115] supabase_admin@postgres LOG:  statement: drop extension if exists pg_graphql;
DROP EXTENSION
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220609081115_grant-supabase-auth-admin-and-supabase-storage-admin-to-postgres.sql
[local] 2025-04-13 14:47:54.569 UTC [117] supabase_admin@postgres LOG:  statement: grant supabase_auth_admin, supabase_storage_admin to postgres;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220613123923_pg_graphql-pg-dump-perms.sql
[local] 2025-04-13 14:47:54.577 UTC [119] supabase_admin@postgres LOG:  statement: create or replace function extensions.grant_pg_graphql_access()
	    returns event_trigger
	    language plpgsql
	AS $func$
	DECLARE
	    func_is_graphql_resolve bool;
	BEGIN
	    func_is_graphql_resolve = (
	        SELECT n.proname = 'resolve'
	        FROM pg_event_trigger_ddl_commands() AS ev
	        LEFT JOIN pg_catalog.pg_proc AS n
	        ON ev.objid = n.oid
	    );
	
	    IF func_is_graphql_resolve
	    THEN
	        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
	        DROP FUNCTION IF EXISTS graphql_public.graphql;
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language sql
	        as $$
	            select graphql.resolve(
	                query := query,
	                variables := coalesce(variables, '{}'),
	                "operationName" := "operationName",
	                extensions := extensions
	            );
	        $$;
	
	        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
	        -- function in the extension so we need to grant permissions on existing entities AND
	        -- update default permissions to any others that are created after `graphql.resolve`
	        grant usage on schema graphql to postgres, anon, authenticated, service_role;
	        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
	        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
	        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
	    END IF;
	
	END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.580 UTC [119] supabase_admin@postgres LOG:  statement: drop extension if exists pg_graphql;
DROP EXTENSION
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20220713082019_pg_cron-pg_net-temp-perms-fix.sql
DO
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20221028101028_set_authenticator_timeout.sql
[local] 2025-04-13 14:47:54.607 UTC [123] supabase_admin@postgres LOG:  statement: alter role authenticator set statement_timeout = '8s';
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20221103090837_revoke_admin.sql
[local] 2025-04-13 14:47:54.615 UTC [125] supabase_admin@postgres LOG:  statement: revoke supabase_admin from authenticator;
REVOKE ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20221207154255_create_pgsodium_and_vault.sql
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20230201083204_grant_auth_roles_to_postgres.sql
[local] 2025-04-13 14:47:54.787 UTC [129] supabase_admin@postgres LOG:  statement: grant anon, authenticated, service_role to postgres;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20230224042246_grant_extensions_perms_for_postgres.sql
[local] 2025-04-13 14:47:54.796 UTC [131] supabase_admin@postgres LOG:  statement: grant all privileges on all tables in schema extensions to postgres with grant option;
GRANT
[local] 2025-04-13 14:47:54.797 UTC [131] supabase_admin@postgres LOG:  statement: grant all privileges on all routines in schema extensions to postgres with grant option;
GRANT
[local] 2025-04-13 14:47:54.799 UTC [131] supabase_admin@postgres LOG:  statement: grant all privileges on all sequences in schema extensions to postgres with grant option;
GRANT
[local] 2025-04-13 14:47:54.799 UTC [131] supabase_admin@postgres LOG:  statement: alter default privileges in schema extensions grant all on tables to postgres with grant option;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.800 UTC [131] supabase_admin@postgres LOG:  statement: alter default privileges in schema extensions grant all on routines to postgres with grant option;
ALTER DEFAULT PRIVILEGES
[local] 2025-04-13 14:47:54.801 UTC [131] supabase_admin@postgres LOG:  statement: alter default privileges in schema extensions grant all on sequences to postgres with grant option;
ALTER DEFAULT PRIVILEGES
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20230306081037_grant_pg_monitor_to_postgres.sql
[local] 2025-04-13 14:47:54.810 UTC [133] supabase_admin@postgres LOG:  statement: grant pg_monitor to postgres;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20230327032006_grant_auth_roles_to_supabase_storage_admin.sql
[local] 2025-04-13 14:47:54.818 UTC [135] supabase_admin@postgres LOG:  statement: grant anon, authenticated, service_role to supabase_storage_admin;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20230529180330_alter_api_roles_for_inherit.sql
[local] 2025-04-13 14:47:54.827 UTC [137] supabase_admin@postgres LOG:  statement: ALTER ROLE authenticated inherit;
ALTER ROLE
[local] 2025-04-13 14:47:54.828 UTC [137] supabase_admin@postgres LOG:  statement: ALTER ROLE anon inherit;
ALTER ROLE
[local] 2025-04-13 14:47:54.830 UTC [137] supabase_admin@postgres LOG:  statement: ALTER ROLE service_role inherit;
ALTER ROLE
[local] 2025-04-13 14:47:54.831 UTC [137] supabase_admin@postgres LOG:  statement: GRANT pgsodium_keyholder to service_role;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20231013070755_grant_authenticator_to_supabase_storage_admin.sql
[local] 2025-04-13 14:47:54.840 UTC [139] supabase_admin@postgres LOG:  statement: grant authenticator to supabase_storage_admin;
GRANT ROLE
[local] 2025-04-13 14:47:54.841 UTC [139] supabase_admin@postgres LOG:  statement: revoke anon, authenticated, service_role from supabase_storage_admin;
REVOKE ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20231017062225_grant_pg_graphql_permissions_for_custom_roles.sql
[local] 2025-04-13 14:47:54.850 UTC [141] supabase_admin@postgres LOG:  statement: create or replace function extensions.grant_pg_graphql_access()
	    returns event_trigger
	    language plpgsql
	AS $func$
	DECLARE
	    func_is_graphql_resolve bool;
	BEGIN
	    func_is_graphql_resolve = (
	        SELECT n.proname = 'resolve'
	        FROM pg_event_trigger_ddl_commands() AS ev
	        LEFT JOIN pg_catalog.pg_proc AS n
	        ON ev.objid = n.oid
	    );
	
	    IF func_is_graphql_resolve
	    THEN
	        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
	        DROP FUNCTION IF EXISTS graphql_public.graphql;
	        create or replace function graphql_public.graphql(
	            "operationName" text default null,
	            query text default null,
	            variables jsonb default null,
	            extensions jsonb default null
	        )
	            returns jsonb
	            language sql
	        as $$
	            select graphql.resolve(
	                query := query,
	                variables := coalesce(variables, '{}'),
	                "operationName" := "operationName",
	                extensions := extensions
	            );
	        $$;
	
	        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
	        -- function in the extension so we need to grant permissions on existing entities AND
	        -- update default permissions to any others that are created after `graphql.resolve`
	        grant usage on schema graphql to postgres, anon, authenticated, service_role;
	        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
	        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
	        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
	        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
	
	        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
	        grant usage on schema graphql_public to postgres with grant option;
	        grant usage on schema graphql to postgres with grant option;
	    END IF;
	
	END;
	$func$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.852 UTC [141] supabase_admin@postgres LOG:  statement: drop extension if exists pg_graphql;
DROP EXTENSION
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20231020085357_revoke_writes_on_cron_job_from_postgres.sql
DO
[local] 2025-04-13 14:47:54.869 UTC [143] supabase_admin@postgres LOG:  statement: CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
	    LANGUAGE plpgsql
	    AS $$
	BEGIN
	  IF EXISTS (
	    SELECT
	    FROM pg_event_trigger_ddl_commands() AS ev
	    JOIN pg_extension AS ext
	    ON ev.objid = ext.oid
	    WHERE ext.extname = 'pg_cron'
	  )
	  THEN
	    grant usage on schema cron to postgres with grant option;
	
	    alter default privileges in schema cron grant all on tables to postgres with grant option;
	    alter default privileges in schema cron grant all on functions to postgres with grant option;
	    alter default privileges in schema cron grant all on sequences to postgres with grant option;
	
	    alter default privileges for user supabase_admin in schema cron grant all
	        on sequences to postgres with grant option;
	    alter default privileges for user supabase_admin in schema cron grant all
	        on tables to postgres with grant option;
	    alter default privileges for user supabase_admin in schema cron grant all
	        on functions to postgres with grant option;
	
	    grant all privileges on all tables in schema cron to postgres with grant option;
	    revoke all on table cron.job from postgres;
	    grant select on table cron.job to postgres with grant option;
	  END IF;
	END;
	$$;
CREATE FUNCTION
[local] 2025-04-13 14:47:54.871 UTC [143] supabase_admin@postgres LOG:  statement: drop event trigger if exists issue_pg_cron_access;
DROP EVENT TRIGGER
[local] 2025-04-13 14:47:54.872 UTC [143] supabase_admin@postgres LOG:  statement: CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
	         WHEN TAG IN ('CREATE EXTENSION')
	   EXECUTE FUNCTION extensions.grant_pg_cron_access();
CREATE EVENT TRIGGER
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20231130133139_set_lock_timeout_to_authenticator_role.sql
[local] 2025-04-13 14:47:54.881 UTC [145] supabase_admin@postgres LOG:  statement: ALTER ROLE authenticator set lock_timeout to '8s';
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20240124080435_alter_lo_export_lo_import_owner.sql
[local] 2025-04-13 14:47:54.889 UTC [147] supabase_admin@postgres LOG:  statement: alter function pg_catalog.lo_export owner to supabase_admin;
ALTER FUNCTION
[local] 2025-04-13 14:47:54.890 UTC [147] supabase_admin@postgres LOG:  statement: alter function pg_catalog.lo_import(text) owner to supabase_admin;
ALTER FUNCTION
[local] 2025-04-13 14:47:54.890 UTC [147] supabase_admin@postgres LOG:  statement: alter function pg_catalog.lo_import(text, oid) owner to supabase_admin;
ALTER FUNCTION
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20240606060239_grant_predefined_roles_to_postgres.sql
[local] 2025-04-13 14:47:54.898 UTC [149] supabase_admin@postgres LOG:  statement: grant pg_read_all_data, pg_signal_backend to postgres;
GRANT ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20241031003909_create_orioledb.sql
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20241215003910_backfill_pgmq_metadata.sql
DO
DO
/docker-entrypoint-initdb.d/migrate.sh: running /docker-entrypoint-initdb.d/migrations/20250205060043_disable_log_statement_on_internal_roles.sql
[local] 2025-04-13 14:47:54.924 UTC [155] supabase_admin@postgres LOG:  statement: alter role supabase_admin set log_statement = none;
ALTER ROLE
[local] 2025-04-13 14:47:54.926 UTC [155] supabase_admin@postgres LOG:  statement: alter role supabase_auth_admin set log_statement = none;
ALTER ROLE
[local] 2025-04-13 14:47:54.927 UTC [155] supabase_admin@postgres LOG:  statement: alter role supabase_storage_admin set log_statement = none;
ALTER ROLE
/docker-entrypoint-initdb.d/migrate.sh: running /etc/postgresql.schema.sql
ALTER DATABASE
ALTER DATABASE
ALTER ROLE
ALTER ROLE
ALTER ROLE
ALTER ROLE
ALTER ROLE
ALTER ROLE
ALTER ROLE
CREATE SCHEMA
ALTER SCHEMA
BEGIN
CREATE EXTENSION
CREATE SCHEMA
GRANT
ALTER DEFAULT PRIVILEGES
ALTER DEFAULT PRIVILEGES
ALTER DEFAULT PRIVILEGES
CREATE TABLE
INSERT 0 1
CREATE TABLE
CREATE INDEX
CREATE INDEX
COMMENT
CREATE FUNCTION
DO
GRANT
GRANT
GRANT
ALTER ROLE
ALTER TABLE
ALTER TABLE
ALTER FUNCTION
GRANT ROLE
DO
DO
CREATE FUNCTION
COMMENT
DO
INSERT 0 1
ALTER FUNCTION
ALTER FUNCTION
REVOKE
GRANT
COMMIT
CREATE DATABASE
You are now connected to database "_supabase" as user "supabase_admin".
CREATE SCHEMA
ALTER SCHEMA
CREATE SCHEMA
ALTER SCHEMA
You are now connected to database "postgres" as user "supabase_admin".
 pg_stat_statements_reset 
--------------------------
 
(1 row)

 pg_stat_reset 
---------------
 
(1 row)


/usr/local/bin/docker-entrypoint.sh: ignoring /docker-entrypoint-initdb.d/migrations

waiting for server to shut down.... 2025-04-13 14:47:55.064 UTC [54] LOG:  received fast shutdown request
 2025-04-13 14:47:55.066 UTC [54] LOG:  aborting any active transactions
 2025-04-13 14:47:55.066 UTC [65] LOG:  pg_cron scheduler shutting down
 2025-04-13 14:47:55.066 UTC [63] FATAL:  terminating background worker "TimescaleDB Background Worker Launcher" due to administrator command
 2025-04-13 14:47:55.067 UTC [54] LOG:  background worker "TimescaleDB Background Worker Launcher" (PID 63) exited with exit code 1
 2025-04-13 14:47:55.067 UTC [54] LOG:  background worker "pg_cron launcher" (PID 65) exited with exit code 1
 2025-04-13 14:47:55.067 UTC [54] LOG:  background worker "logical replication launcher" (PID 66) exited with exit code 1
. 2025-04-13 14:47:56.070 UTC [54] LOG:  background worker "pg_net 0.14.0 worker" (PID 64) exited with exit code 1
 2025-04-13 14:47:56.070 UTC [58] LOG:  shutting down
 2025-04-13 14:47:56.073 UTC [58] LOG:  checkpoint starting: shutdown immediate
 2025-04-13 14:47:56.319 UTC [58] LOG:  checkpoint complete: wrote 1275 buffers (7.8%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.013 s, sync=0.227 s, total=0.249 s; sync files=511, longest=0.003 s, average=0.001 s; distance=7159 kB, estimate=7159 kB
 2025-04-13 14:47:56.328 UTC [54] LOG:  database system is shut down
 done
server stopped

PostgreSQL init process complete; ready for start up.


-- Enable PostGIS extension (already enabled in Supabase)
-- CREATE EXTENSION IF NOT EXISTS postgis;

-- Create enum for feature types
CREATE TYPE public.feature_type AS ENUM (
    'Point',
    'LineString',
    'Polygon',
    'MultiPoint',
    'MultiLineString',
    'MultiPolygon',
    'GeometryCollection'
);

-- Create table for feature collections (imported files)
CREATE TABLE public.feature_collections (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    file_type VARCHAR(50) NOT NULL, -- e.g., 'dxf', 'shp'
    coordinate_system VARCHAR(50), -- EPSG code or custom CRS
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    metadata JSONB,
    user_id UUID REFERENCES auth.users(id) NOT NULL
);

-- Create table for layers
CREATE TABLE public.layers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    collection_id bigint REFERENCES public.feature_collections(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    visible BOOLEAN DEFAULT true,
    style JSONB, -- Layer styling information
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    metadata JSONB,
    user_id UUID REFERENCES auth.users(id) NOT NULL
);

-- Create table for geometric features
CREATE TABLE public.geo_features (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    layer_id bigint REFERENCES public.layers(id) ON DELETE CASCADE,
    feature_type feature_type NOT NULL,
    properties JSONB,
    geometry geometry(Geometry, 4326) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    CONSTRAINT valid_geometry CHECK (ST_IsValid(geometry))
);

-- Create spatial index
CREATE INDEX geo_features_geometry_idx ON public.geo_features USING GIST (geometry);

-- Create indexes for common queries
CREATE INDEX layers_collection_id_idx ON public.layers(collection_id);
CREATE INDEX geo_features_layer_id_idx ON public.geo_features(layer_id);

-- Enable Row Level Security
ALTER TABLE public.feature_collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.layers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.geo_features ENABLE ROW LEVEL SECURITY;

-- Create RLS Policies
CREATE POLICY "Users can view their own feature collections"
    ON public.feature_collections
    FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own feature collections"
    ON public.feature_collections
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view their own layers"
    ON public.layers
    FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own layers"
    ON public.layers
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view their own features"
    ON public.geo_features
    FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own features"
    ON public.geo_features
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Create function for PostGIS queries (to be used via RPC)
CREATE OR REPLACE FUNCTION public.postgis_query(query_text text, query_params json DEFAULT '[]'::json)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN (SELECT json_agg(row_to_json(t))
            FROM json_array_elements(query_params) WITH ORDINALITY AS params(value, idx)
            CROSS JOIN LATERAL (
                SELECT * FROM query_text AS t
            ) t);
END;
$$; 